{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Matchmaking Service What is it? Matchmaking Service is an attempt to bring cross-server matchmaking with built in skill-based matchmaking (if you want to use it). Utilizing the new Memory Store Service for fast-based high throughput potentital, Matchmaking Service will keep up even with bigger games. Matchmaking Service is made to be easy to use. It exposes a fully documented API to developers so they can enjoy the sweet, sweet theory of programming abstraction. However, if you're interested in the guts of the program, it is fully open source and available on our github . That means you can keep up to date with its development and even contribute, open issues, and request new features all in one place. This makes it easy for our contributors to keep track of everything as well. Skill-based matchmaking? Matchmaking Service provides built in skill-based matchmaking using a luau OpenSkill implementation (which you can find here ). This means that your players won't have to deal with going against opponents they have no chance at beating and it means that you can provide your players with the amazing rank up feeling... if you choose. Of course because not everybody likes skill-based matchmaking, it is completely optional. You can disable it as well. If you disable it, anywhere you would normally pass a ratingType , just pass nil . Getting started Check out our getting started page for more information on how basic implementation of this system works.","title":"Home"},{"location":"#matchmaking-service","text":"","title":"Matchmaking Service"},{"location":"#what-is-it","text":"Matchmaking Service is an attempt to bring cross-server matchmaking with built in skill-based matchmaking (if you want to use it). Utilizing the new Memory Store Service for fast-based high throughput potentital, Matchmaking Service will keep up even with bigger games. Matchmaking Service is made to be easy to use. It exposes a fully documented API to developers so they can enjoy the sweet, sweet theory of programming abstraction. However, if you're interested in the guts of the program, it is fully open source and available on our github . That means you can keep up to date with its development and even contribute, open issues, and request new features all in one place. This makes it easy for our contributors to keep track of everything as well.","title":"What is it?"},{"location":"#skill-based-matchmaking","text":"Matchmaking Service provides built in skill-based matchmaking using a luau OpenSkill implementation (which you can find here ). This means that your players won't have to deal with going against opponents they have no chance at beating and it means that you can provide your players with the amazing rank up feeling... if you choose. Of course because not everybody likes skill-based matchmaking, it is completely optional. You can disable it as well. If you disable it, anywhere you would normally pass a ratingType , just pass nil .","title":"Skill-based matchmaking?"},{"location":"#getting-started","text":"Check out our getting started page for more information on how basic implementation of this system works.","title":"Getting started"},{"location":"gettingstarted/","text":"Getting Started Getting the module While I personally recommend requiring the module directly by id to stay up to date, there are a number of reasons why you may choose to not do this. For this reason the module itself is available to add to your roblox inventory here . Preface Matchmaking Service requires at least 2 games in a single universe to work. We call these hub servers and instance servers. Your hub servers are responsible for adding players to queues. Your instance servers are where the actual game will take place, this is where you want all of your game logic to go. We'll be starting off with the basic hub server logic. Matchmaking Service currently utilizes a central server to handle all matchmaking. We are looking into ways to distributing this and having a fully decentralized hub for performance, but no great solution has been found. For this reason I do not recommend having 1 player max hub servers as that means it's constantly switching central servers which is less than ideal. Hub logic Obtaining the MatchmakingService Singleton Matchmaking Service utilizes a top-level singleton. This means every time you require it and invoke GetSingleton in the same server the same singleton is returned. Getting this singleton is really simple: local MatchmakingService = require ( 7567983240 ). GetSingleton () -- You may opt to use a direct path to it if you don't want to require by id Setting the instance server As said in the preface, Matchmaking Service uses hub servers and instance servers. Instance servers are your game servers. They are the place players are teleported to when a match is found. For this step you will need the place id of your instance server. This is simple to obtain. First, open the instance server's place in studio. Then in your console type print(game.PlaceId) . The result is the place id that you will need for this step. Alternatively, use the asset manager and right click on the place and \"Copy ID to clipboard\": local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : AddGamePlace ( \"Map Name\" , placeIdYouCopied ) -- Instance and hub servers must exist in the same universe And believe it or not, that's it. That is the most basic implementation of a hub server without changing any of the values. Setting the player range The player range controls the min and max players for a game. If you think about many other multiplayer games, the game might start while the server is not full or it might want to wait for a full server to move players into the game. Using NumberRanges makes this functionality easy. local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : SetPlayerRange ( \"Map Name\" , NumberRange . new ( 5 , 10 )) What this does is tells the queue to teleport players to the instance server when there are at least 5, but allows new players to be added to the game until there are 10. Queueing players Queueing players is simple, you can do this from a gui remote event, on join or anywhere (from the server): local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : QueuePlayer ( p , \"unranked\" , \"Map Name\" ) This will queue a player into the unranked lobby (note, just because it's unranked does not mean it's not rated. All rank types will have a rating attached to them, but it's up to you whether you want to update it or not). This means they will only search for other players in the same lobby. There are no huge limits on this, except I recommend to keep the size under 20 characters. Queueing parties Matchmaking Service provides an easy way to queue multiple players at the same time and ensure they get into the same game. However, Matchmaking Service will not handle forming parties or ensuring they're on the same team in instance servers, that is something you will have to do. local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : QueueParty ( players , \"unranked\" , \"Map Name\" ) -- Players is a table of player objects When you do this, they will be guaranteed to get into the same server. Removing single players from the queue By default, Matchmaking Service will handle removing players from the queue when they get into a game or leave the hub. However, you may want to give them the option to remove themselves from queue, so Matchmaking Service exposes a method for this: local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : RemovePlayerFromQueue ( player ) This will remove them from the queue, no matter what lobby they're in. If they are not queued, then this will do nothing. Removing multiple players from the queue Removing multiple players from the queue at the same time is helpful to drastically reduce the number of calls to memory, which means lower chance of hitting the cap and breaking the system. This is also the easiest way to remove parties from the queue. local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : RemovePlayersFromQueue ( players ) --- Players is a table of player objects Note: This function is more efficient on memory updates if all of the users are in the same lobby type, however it is not required. Instance server logic Instance servers are also simple. This section will go over the most basic instance server implementation and everything that is required to make it work. Denoating a server as a game instance It's important to denote a server as a game instance as this removes the ability for it to become the central server, and removes logic that may impact game performance. You should set the player range to match that of the hub server You can choose to set the field directly, but I recommend that you use the built in method in case anything changes in the future: local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : SetIsGameServer ( true ) MatchmakingService : SetPlayerRange ( \"Map 1\" , NumberRange . new ( 2 , 2 )) Obtaining teleport data from the server Data about the match is sent over the players' teleport data. This prevents additional calls to the memory store which means queues can run faster. I recommend doing this right in player join, but you could theoretically do it at any time you'd like. game . Players . PlayerAdded : Connect ( function ( player ) local joinData = player : GetJoinData () if _G . gameId == nil and joinData then -- Global variables are not recommended in a lot of cases. -- However, here it would be nice to have access to them, -- regardless of scope. Mainly because this server instance -- will be destroyed when the game is over so you needn't -- worry about this causing long-standing memory leaks. _G . gameId = joinData . TeleportData . gameCode _G . ratingType = joinData . TeleportData . ratingType end end ) Starting the game Starting the game is important because it tells the queue manager that the game is started, you can also pass a boolean value that determines whether or not the game is joinable still. By default the game will not be joinable if no value is passed. function Start () -- Start the game, but allow new joiners MatchmakingService : StartGame ( _G . gameId , true ) end Manually removing a player from a game You may manually remove players from games when they leave to open up spots for new players in games. You can do that with the following script. Note: for this to work properly, the player range in the hub server and instance server must match. game . Players . PlayerRemoving : Connect ( function ( player ) MatchmakingService : RemovePlayerFromGame ( player , _G . gameId ) end ) Ending the game This step is extremely important and significantly reduces memory footprint of games. If you don't do this they will reside in memory until it's cleared. You must include these 3 lines of code. The only reason I don't implement it into the base system is because you may want to run actions before you remove a game. game : BindToClose ( function () MatchmakingService : RemoveGame ( _G . gameId ) end ) Updating rating As noted previously, Matchmaking Service has a built in rating system. If you want to use it, you'll have to manually invoke the UpdateRatings function. If you don't invoke this function, the players' rating will never change and it'll be essentially the same as having no rating at all. Updating rating must be done before BindToClose . This means that you will need your own end game functionality. This script is an example of one way you may choose to implement this functionality: function EndGame ( winner ) MatchmakingService : UpdateRatings ( _G . ratingType , { 2 , 1 , 3 }, { team1 , team2 , team3 }) for i , v in ipairs ( game . Players : GetPlayers ()) do -- You can teleport them back to the hub here, I just kick them v : Kick () end end The line we'll be focusing on is as follows: MatchmakingService : UpdateRatings ( _G . ratingType , { 2 , 1 , 3 }, { team1 , team2 , team3 }) - _G.ratingType is the rating type they queued for. This is passed in teleport data - {2, 1, 3} is the positional placements of each team (order is important, rankings[1] is paired to teams[1] ). Lower is better. 1 means first place, 2 is second and so on. This supports any number of rankings, but it must match the number of teams. - {team1, team2, team3} are the teams themselves. Each team is a table of players on that team (even if there is only 1 player, it must be in a table). The order is important as they are paired to the same index as their ranking. That's really it for server instances. The only things you are required to do for a smooth experience is denoting the server as a game server and removing the game on close. Updating ratings is optional. Full example scripts Extremely basic 1v1 game hub server: -- Obtain the service local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : SetPlayerRange ( \"Map 1\" , NumberRange . new ( 2 , 2 )) -- 2, 2 means min players 2, max players 2 (or 1v1) -- Set the game place, this game must exist in the same universe MatchmakingService : SetGamePlace ( \"Map 1\" , gamePlaceIdHere ) -- Queue players (you can call QueuePlayer from anywhere) game . Players . PlayerAdded : Connect ( function ( p ) MatchmakingService : QueuePlayer ( p , \"queue\" , \"Map 1\" ) -- \"queue\" can be any string you want, so can the map end ) for i , p in ipairs ( game . Players : GetPlayers ()) do MatchmakingService : QueuePlayer ( p , \"queue\" , \"Map 1\" ) -- \"queue\" can be any string you want, so can the map end Extremely basic 1v1 game instance server (EndGame is not called in this example): local MatchmakingService = require ( 7567983240 ). GetSingleton () -- It's important game servers know how large they can get. You don't really need every map here, -- but you do need whichever map this is. MatchmakingService : SetPlayerRange ( \"Map 1\" , NumberRange . new ( 2 , 2 )) -- Tell the service this is a game server MatchmakingService : SetIsGameServer ( true ) local t1 = {} local t2 = {} -- Basic start function function Start () print ( \"Started\" ) MatchmakingService : StartGame ( _G . gameId ) -- Simple teams for a 1v1. local p = game . Players : GetPlayers () table.insert ( t1 , p [ 1 ]) table.insert ( t2 , p [ 2 ]) end -- YOU MUST CALL UpdateRatings BEFORE THE GAME IS CLOSED. YOU CANNOT PUT THIS IN BindToClose! function EndGame ( winner ) MatchmakingService : UpdateRatings ( _G . ratingType , { if winner == 1 then 1 else 2 , if winner == 2 then 1 , else 2 }, { t1 , t2 }) for i , v in ipairs ( game . Players : GetPlayers ()) do -- You can teleport them back to the hub here, I just kick them v : Kick () end end game . Players . PlayerAdded : Connect ( function ( player ) local joinData = player : GetJoinData () if _G . gameId == nil and joinData then -- Global so its accessible from other scripts if it needs to be. _G . gameId = joinData . TeleportData . gameCode _G . ratingType = joinData . TeleportData . ratingType end if # game . Players : GetPlayers () >= 2 then Start () end end ) game . Players . PlayerRemoving : Connect ( function ( player ) MatchmakingService : RemovePlayerFromGame ( player , _G . gameId ) end ) -- THIS IS EXTREMELY IMPORTANT game : BindToClose ( function () MatchmakingService : RemoveGame ( _G . gameId ) end ) Conclusion As you can see, with under 50 lines of code, you can have fully functional cross-server match making. This is just the tip of the iceberg with Matchmaking Service as well. For more in-depth documentation see the main docs . If you encounter any issues don't hesitate to open an issue . If you need assistance, feel free to contact me on dev forum.","title":"Getting Started"},{"location":"gettingstarted/#getting-started","text":"","title":"Getting Started"},{"location":"gettingstarted/#getting-the-module","text":"While I personally recommend requiring the module directly by id to stay up to date, there are a number of reasons why you may choose to not do this. For this reason the module itself is available to add to your roblox inventory here .","title":"Getting the module"},{"location":"gettingstarted/#preface","text":"Matchmaking Service requires at least 2 games in a single universe to work. We call these hub servers and instance servers. Your hub servers are responsible for adding players to queues. Your instance servers are where the actual game will take place, this is where you want all of your game logic to go. We'll be starting off with the basic hub server logic. Matchmaking Service currently utilizes a central server to handle all matchmaking. We are looking into ways to distributing this and having a fully decentralized hub for performance, but no great solution has been found. For this reason I do not recommend having 1 player max hub servers as that means it's constantly switching central servers which is less than ideal.","title":"Preface"},{"location":"gettingstarted/#hub-logic","text":"","title":"Hub logic"},{"location":"gettingstarted/#obtaining-the-matchmakingservice-singleton","text":"Matchmaking Service utilizes a top-level singleton. This means every time you require it and invoke GetSingleton in the same server the same singleton is returned. Getting this singleton is really simple: local MatchmakingService = require ( 7567983240 ). GetSingleton () -- You may opt to use a direct path to it if you don't want to require by id","title":"Obtaining the MatchmakingService Singleton"},{"location":"gettingstarted/#setting-the-instance-server","text":"As said in the preface, Matchmaking Service uses hub servers and instance servers. Instance servers are your game servers. They are the place players are teleported to when a match is found. For this step you will need the place id of your instance server. This is simple to obtain. First, open the instance server's place in studio. Then in your console type print(game.PlaceId) . The result is the place id that you will need for this step. Alternatively, use the asset manager and right click on the place and \"Copy ID to clipboard\": local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : AddGamePlace ( \"Map Name\" , placeIdYouCopied ) -- Instance and hub servers must exist in the same universe And believe it or not, that's it. That is the most basic implementation of a hub server without changing any of the values.","title":"Setting the instance server"},{"location":"gettingstarted/#setting-the-player-range","text":"The player range controls the min and max players for a game. If you think about many other multiplayer games, the game might start while the server is not full or it might want to wait for a full server to move players into the game. Using NumberRanges makes this functionality easy. local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : SetPlayerRange ( \"Map Name\" , NumberRange . new ( 5 , 10 )) What this does is tells the queue to teleport players to the instance server when there are at least 5, but allows new players to be added to the game until there are 10.","title":"Setting the player range"},{"location":"gettingstarted/#queueing-players","text":"Queueing players is simple, you can do this from a gui remote event, on join or anywhere (from the server): local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : QueuePlayer ( p , \"unranked\" , \"Map Name\" ) This will queue a player into the unranked lobby (note, just because it's unranked does not mean it's not rated. All rank types will have a rating attached to them, but it's up to you whether you want to update it or not). This means they will only search for other players in the same lobby. There are no huge limits on this, except I recommend to keep the size under 20 characters.","title":"Queueing players"},{"location":"gettingstarted/#queueing-parties","text":"Matchmaking Service provides an easy way to queue multiple players at the same time and ensure they get into the same game. However, Matchmaking Service will not handle forming parties or ensuring they're on the same team in instance servers, that is something you will have to do. local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : QueueParty ( players , \"unranked\" , \"Map Name\" ) -- Players is a table of player objects When you do this, they will be guaranteed to get into the same server.","title":"Queueing parties"},{"location":"gettingstarted/#removing-single-players-from-the-queue","text":"By default, Matchmaking Service will handle removing players from the queue when they get into a game or leave the hub. However, you may want to give them the option to remove themselves from queue, so Matchmaking Service exposes a method for this: local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : RemovePlayerFromQueue ( player ) This will remove them from the queue, no matter what lobby they're in. If they are not queued, then this will do nothing.","title":"Removing single players from the queue"},{"location":"gettingstarted/#removing-multiple-players-from-the-queue","text":"Removing multiple players from the queue at the same time is helpful to drastically reduce the number of calls to memory, which means lower chance of hitting the cap and breaking the system. This is also the easiest way to remove parties from the queue. local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : RemovePlayersFromQueue ( players ) --- Players is a table of player objects Note: This function is more efficient on memory updates if all of the users are in the same lobby type, however it is not required.","title":"Removing multiple players from the queue"},{"location":"gettingstarted/#instance-server-logic","text":"Instance servers are also simple. This section will go over the most basic instance server implementation and everything that is required to make it work.","title":"Instance server logic"},{"location":"gettingstarted/#denoating-a-server-as-a-game-instance","text":"It's important to denote a server as a game instance as this removes the ability for it to become the central server, and removes logic that may impact game performance. You should set the player range to match that of the hub server You can choose to set the field directly, but I recommend that you use the built in method in case anything changes in the future: local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : SetIsGameServer ( true ) MatchmakingService : SetPlayerRange ( \"Map 1\" , NumberRange . new ( 2 , 2 ))","title":"Denoating a server as a game instance"},{"location":"gettingstarted/#obtaining-teleport-data-from-the-server","text":"Data about the match is sent over the players' teleport data. This prevents additional calls to the memory store which means queues can run faster. I recommend doing this right in player join, but you could theoretically do it at any time you'd like. game . Players . PlayerAdded : Connect ( function ( player ) local joinData = player : GetJoinData () if _G . gameId == nil and joinData then -- Global variables are not recommended in a lot of cases. -- However, here it would be nice to have access to them, -- regardless of scope. Mainly because this server instance -- will be destroyed when the game is over so you needn't -- worry about this causing long-standing memory leaks. _G . gameId = joinData . TeleportData . gameCode _G . ratingType = joinData . TeleportData . ratingType end end )","title":"Obtaining teleport data from the server"},{"location":"gettingstarted/#starting-the-game","text":"Starting the game is important because it tells the queue manager that the game is started, you can also pass a boolean value that determines whether or not the game is joinable still. By default the game will not be joinable if no value is passed. function Start () -- Start the game, but allow new joiners MatchmakingService : StartGame ( _G . gameId , true ) end","title":"Starting the game"},{"location":"gettingstarted/#manually-removing-a-player-from-a-game","text":"You may manually remove players from games when they leave to open up spots for new players in games. You can do that with the following script. Note: for this to work properly, the player range in the hub server and instance server must match. game . Players . PlayerRemoving : Connect ( function ( player ) MatchmakingService : RemovePlayerFromGame ( player , _G . gameId ) end )","title":"Manually removing a player from a game"},{"location":"gettingstarted/#ending-the-game","text":"This step is extremely important and significantly reduces memory footprint of games. If you don't do this they will reside in memory until it's cleared. You must include these 3 lines of code. The only reason I don't implement it into the base system is because you may want to run actions before you remove a game. game : BindToClose ( function () MatchmakingService : RemoveGame ( _G . gameId ) end )","title":"Ending the game"},{"location":"gettingstarted/#updating-rating","text":"As noted previously, Matchmaking Service has a built in rating system. If you want to use it, you'll have to manually invoke the UpdateRatings function. If you don't invoke this function, the players' rating will never change and it'll be essentially the same as having no rating at all. Updating rating must be done before BindToClose . This means that you will need your own end game functionality. This script is an example of one way you may choose to implement this functionality: function EndGame ( winner ) MatchmakingService : UpdateRatings ( _G . ratingType , { 2 , 1 , 3 }, { team1 , team2 , team3 }) for i , v in ipairs ( game . Players : GetPlayers ()) do -- You can teleport them back to the hub here, I just kick them v : Kick () end end The line we'll be focusing on is as follows: MatchmakingService : UpdateRatings ( _G . ratingType , { 2 , 1 , 3 }, { team1 , team2 , team3 }) - _G.ratingType is the rating type they queued for. This is passed in teleport data - {2, 1, 3} is the positional placements of each team (order is important, rankings[1] is paired to teams[1] ). Lower is better. 1 means first place, 2 is second and so on. This supports any number of rankings, but it must match the number of teams. - {team1, team2, team3} are the teams themselves. Each team is a table of players on that team (even if there is only 1 player, it must be in a table). The order is important as they are paired to the same index as their ranking. That's really it for server instances. The only things you are required to do for a smooth experience is denoting the server as a game server and removing the game on close. Updating ratings is optional.","title":"Updating rating"},{"location":"gettingstarted/#full-example-scripts","text":"Extremely basic 1v1 game hub server: -- Obtain the service local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : SetPlayerRange ( \"Map 1\" , NumberRange . new ( 2 , 2 )) -- 2, 2 means min players 2, max players 2 (or 1v1) -- Set the game place, this game must exist in the same universe MatchmakingService : SetGamePlace ( \"Map 1\" , gamePlaceIdHere ) -- Queue players (you can call QueuePlayer from anywhere) game . Players . PlayerAdded : Connect ( function ( p ) MatchmakingService : QueuePlayer ( p , \"queue\" , \"Map 1\" ) -- \"queue\" can be any string you want, so can the map end ) for i , p in ipairs ( game . Players : GetPlayers ()) do MatchmakingService : QueuePlayer ( p , \"queue\" , \"Map 1\" ) -- \"queue\" can be any string you want, so can the map end Extremely basic 1v1 game instance server (EndGame is not called in this example): local MatchmakingService = require ( 7567983240 ). GetSingleton () -- It's important game servers know how large they can get. You don't really need every map here, -- but you do need whichever map this is. MatchmakingService : SetPlayerRange ( \"Map 1\" , NumberRange . new ( 2 , 2 )) -- Tell the service this is a game server MatchmakingService : SetIsGameServer ( true ) local t1 = {} local t2 = {} -- Basic start function function Start () print ( \"Started\" ) MatchmakingService : StartGame ( _G . gameId ) -- Simple teams for a 1v1. local p = game . Players : GetPlayers () table.insert ( t1 , p [ 1 ]) table.insert ( t2 , p [ 2 ]) end -- YOU MUST CALL UpdateRatings BEFORE THE GAME IS CLOSED. YOU CANNOT PUT THIS IN BindToClose! function EndGame ( winner ) MatchmakingService : UpdateRatings ( _G . ratingType , { if winner == 1 then 1 else 2 , if winner == 2 then 1 , else 2 }, { t1 , t2 }) for i , v in ipairs ( game . Players : GetPlayers ()) do -- You can teleport them back to the hub here, I just kick them v : Kick () end end game . Players . PlayerAdded : Connect ( function ( player ) local joinData = player : GetJoinData () if _G . gameId == nil and joinData then -- Global so its accessible from other scripts if it needs to be. _G . gameId = joinData . TeleportData . gameCode _G . ratingType = joinData . TeleportData . ratingType end if # game . Players : GetPlayers () >= 2 then Start () end end ) game . Players . PlayerRemoving : Connect ( function ( player ) MatchmakingService : RemovePlayerFromGame ( player , _G . gameId ) end ) -- THIS IS EXTREMELY IMPORTANT game : BindToClose ( function () MatchmakingService : RemoveGame ( _G . gameId ) end )","title":"Full example scripts"},{"location":"gettingstarted/#conclusion","text":"As you can see, with under 50 lines of code, you can have fully functional cross-server match making. This is just the tip of the iceberg with Matchmaking Service as well. For more in-depth documentation see the main docs . If you encounter any issues don't hesitate to open an issue . If you need assistance, feel free to contact me on dev forum.","title":"Conclusion"},{"location":"maindocs/","text":"Preface This documentation will provide the insight on to every method available from Matchmaking Service. This will include methods intended for internal use, these are still documented, just in case you ever need them. Note Every method here that involves a player object most likely also has an \"Id\" variant. Internally, everything is done with user ids, but the helper methods exist to streamline the process. This means if you see a method called RemovePlayersFromGame , there is another method called RemovePlayersFromGameId where instead of player objects, user ids are passed. If you're in doubt whether or not an id variant exists for the method you are using, I recommend looking through the source , if it exists, it will have the same name suffixed with Id . \"Id\" variants will not be listed here unless there is no regular variant. Obtaining Singleton Gets or creates the top level singleton of the matchmaking service. Parameter Name Type Description Default Value options table The options to provide matchmaking service {} options.DisableRatingSystem boolean Wheter or not to disable the rating system false MatchmakingService . GetSingleton ( options ) Returns Type Description MatchmakingService The matchmaking service singleton Clearing the Memory Clears all memory aside from player data. MatchmakingService : Clear () Setting Matchmaking Interval Sets the matchmaking interval. Parameter Name Type Description Default Value newInterval number The new matchmaking interval MatchmakingService : SetMatchmakingInterval ( newInterval ) Setting the Player Range Sets the min/max players. Parameter Name Type Description Default Value map string The map the player range applies to newPlayerRange number The NumberRange with the min and max players MatchmakingService : SetPlayerRange ( map , newPlayerRange ) Adding A New Map Add a new game place. Parameter Name Type Description Default Value name string The name of the map id number The place id to teleport to MatchmakingService : AddGamePlace ( name , id ) Seting Is Game Server Sets whether or not this is a game server. Note Disables match finding coroutine if newValue is true. Parameter Name Type Description Default Value newValue boolean A boolean that indicates whether or not this server is a game server MatchmakingService : SetIsGameServer ( newValue ) Setting the Starting Ranking Mean Sets the starting mean of OpenSkill objects. Warning Do not modify this unless you know what you're doing. Parameter Name Type Description Default Value newStartingMean number The new starting mean MatchmakingService : SetStartingMean ( newStartingMean ) Setting the Starting Ranking Standard Deviation Sets the starting standard deviation of OpenSkill objects. Warning Do not modify this unless you know what you're doing. Parameter Name Type Description Default Value newStartingStandardDeviation number The new starting standing deviation MatchmakingService : SetStartingStandardDeviation ( newStartingStandardDeviation ) Setting the Max Skill Gap Between Party Members Sets the max gap in rating between party members. Parameter Name Type Description Default Value newMaxGap number The new max gap between party members MatchmakingService : SetMaxPartySkillGap ( newMaxGap ) Obtaining a Rating Value from an OpenSkill Object Turns an OpenSkill object into a single rating number. Parameter Name Type Description Default Value openSkillObject OpenSkill object The OpenSkill object MatchmakingService : ToRatingNumber ( openSkillObject ) Returns Type Description number The single number representation of the object Obtaining an OpenSkill Object Gets or initializes a players OpenSkill object. Note You should not edit this directly unless you know what you're doing. Parameter Name Type Description Default Value player Player The player to get the OpenSkill object of ratingType string The rating type to get MatchmakingService : GetPlayerRating ( player , ratingType ) Returns Type Description OpenSkill object The OpenSkill object (which is just 2 numbers) Setting an OpenSkill Object Sets a player's skill. Note You should not edit this directly unless you know what you're doing. Parameter Name Type Description Default Value player Player The player to get the OpenSkill object of ratingType string The rating type to get rating OpenSkill object The new OpenSkill object MatchmakingService : SetPlayerRating ( player , ratingType , rating ) Clearing a Player's Info Clears the player info. Parameter Name Type Description Default Value player Player The player to clear MatchmakingService : ClearPlayerInfo ( player ) Setting a Player's info Sets the player info. Parameter Name Type Description Default Value player Player The player to update code string The game id that the player will teleport to, if any ratingType string The rating type of their current game, if any party table The player's party (table of user ids including the player) map string The player's queued map, if any MatchmakingService : SetPlayerInfo ( player , code , ratingType , party , map ) Getting a Player's Info Gets the player info. Parameter Name Type Description Default Value player Player The player to get MatchmakingService : GetPlayerInfo ( player ) Returns Type Description table or nil The player info Getting the Queue Gets a table of user ids, ratingTypes, and skillLevels in a specific queue. Parameter Name Type Description Default Value map string The map to get the queue of MatchmakingService : GetQueue ( map ) Returns Type Description table A dictionary of {ratingType: {skillLevel: queue}} where ratingType is the rating type, skillLevel is the skill level pool (a rounded rating), and queue is a table of user ids Queueing a Single Player Queues a player. Parameter Name Type Description Default Value player Player The player to queue ratingType string The rating type to use map string The map to queue them on MatchmakingService : QueuePlayer ( player , ratingType , map ) Returns Type Description boolean A boolean that is true if the player was queued Queueing a Party Queues a party. Parameter Name Type Description Default Value players table<\u200bPlayer> The players to queue ratingType string The rating type to use map string The map to queue them on MatchmakingService : QueueParty ( players , ratingType , map ) Returns Type Description boolean A boolean that is true if the party was queued Player The player that caused the queue to not start string The reason the queue did not start Getting a Player's Party Gets a player's party. Parameter Name Type Description Default Value player Player The player to get the party of MatchmakingService : GetPlayerParty ( player ) Returns Type Description table<\u200bstring> A table of player id's of players in the party including this player Remove a Single Player from the Queue Removes a specific player from the queue. Parameter Name Type Description Default Value player Player The player to remove from queue MatchmakingService : RemovePlayerFromQueue ( player ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error) Remove Multiple Players from the Queue Removes a table of players from the queue. Parameter Name Type Description Default Value players table<\u200bPlayer> The players to remove from queue MatchmakingService : RemovePlayersFromQueue ( players ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error) Adding A Player to an Existing Game Adds a player to a specific existing game. Parameter Name Type Description Default Value player Player The player to add to the game gameId string The id of the game to add the player to updateJoinable boolean Whether or not to update the joinable status of the game MatchmakingService : AddPlayerToGame ( player , gameId , updateJoinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error) Adding Multiple Players to an Existing Game Adds a table of players to a specific existing game. Parameter Name Type Description Default Value player table<\u200bPlayer> The players to add to the game gameId string The id of the game to add the player to updateJoinable boolean Whether or not to update the joinable status of the game MatchmakingService : AddPlayersToGame ( players , gameId , updateJoinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error) Removing a Player from a Game Removes a specific player from an existing game. Parameter Name Type Description Default Value player Player The player to remove from the game gameId string The id of the game to remove the player from updateJoinable boolean Whether or not to update the joinable status of the game MatchmakingService : RemovePlayersFromGame ( players , gameId , updateJoinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error) Updating Ratings Update player ratings after a game is over. Parameter Name Type Description Default Value ratingType string The rating type this is applicable for ranks table<\u200bnumber> The ranks of the teams. #scores should be the same as the #teams teams table<\u200bPlayer> The teams. A table of tables which contain players MatchmakingService : UpdateRatings ( ratingType , ranks , teams ) Explaination Basically, lets have this scenario in the ratingType ranked: local team1 = { player1 , player2 } local team2 = { player3 , player4 } local team3 = { player5 , player6 } Let\u2019s say team2 came first, team1 came second and team3 came third. To update the ratings correctly, you would do this: MatchmakingService:UpdateRatings(\"ranked\", {2, 1, 3}, {team1, team2, team3}) {2,1,3} is important, and so is order. Order is extremely important here. Because I passed the teams in order, I can give the position of each team in order. As previously stated team1 placed second, therefore because team1 is the first team in the teams table, it also has the first value in the rankings table. Returns Type Description boolean A boolean indicating if there was no error (true if there was no error) Set the Game's Joinable Status Sets the joinable status of a game. Parameter Name Type Description Default Value gameId string The id of the game to update joinable boolean Whether or not the game will be joinable MatchmakingService : SetJoinable ( gameId , joinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error) Remove a Game from Memory Removes a game from memory. Parameter Name Type Description Default Value gameId string The game to remove MatchmakingService : RemoveGame ( gameId ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error) Start a Game Starts a game. Parameter Name Type Description Default Value gameId string The game to start joinable boolean Whether or not the game is still joinable MatchmakingService : StartGame ( gameId , joinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Main Documentation"},{"location":"maindocs/#preface","text":"This documentation will provide the insight on to every method available from Matchmaking Service. This will include methods intended for internal use, these are still documented, just in case you ever need them.","title":"Preface"},{"location":"maindocs/#note","text":"Every method here that involves a player object most likely also has an \"Id\" variant. Internally, everything is done with user ids, but the helper methods exist to streamline the process. This means if you see a method called RemovePlayersFromGame , there is another method called RemovePlayersFromGameId where instead of player objects, user ids are passed. If you're in doubt whether or not an id variant exists for the method you are using, I recommend looking through the source , if it exists, it will have the same name suffixed with Id . \"Id\" variants will not be listed here unless there is no regular variant.","title":"Note"},{"location":"maindocs/#obtaining-singleton","text":"Gets or creates the top level singleton of the matchmaking service. Parameter Name Type Description Default Value options table The options to provide matchmaking service {} options.DisableRatingSystem boolean Wheter or not to disable the rating system false MatchmakingService . GetSingleton ( options ) Returns Type Description MatchmakingService The matchmaking service singleton","title":"Obtaining Singleton"},{"location":"maindocs/#clearing-the-memory","text":"Clears all memory aside from player data. MatchmakingService : Clear ()","title":"Clearing the Memory"},{"location":"maindocs/#setting-matchmaking-interval","text":"Sets the matchmaking interval. Parameter Name Type Description Default Value newInterval number The new matchmaking interval MatchmakingService : SetMatchmakingInterval ( newInterval )","title":"Setting Matchmaking Interval"},{"location":"maindocs/#setting-the-player-range","text":"Sets the min/max players. Parameter Name Type Description Default Value map string The map the player range applies to newPlayerRange number The NumberRange with the min and max players MatchmakingService : SetPlayerRange ( map , newPlayerRange )","title":"Setting the Player Range"},{"location":"maindocs/#adding-a-new-map","text":"Add a new game place. Parameter Name Type Description Default Value name string The name of the map id number The place id to teleport to MatchmakingService : AddGamePlace ( name , id )","title":"Adding A New Map"},{"location":"maindocs/#seting-is-game-server","text":"Sets whether or not this is a game server. Note Disables match finding coroutine if newValue is true. Parameter Name Type Description Default Value newValue boolean A boolean that indicates whether or not this server is a game server MatchmakingService : SetIsGameServer ( newValue )","title":"Seting Is Game Server"},{"location":"maindocs/#setting-the-starting-ranking-mean","text":"Sets the starting mean of OpenSkill objects. Warning Do not modify this unless you know what you're doing. Parameter Name Type Description Default Value newStartingMean number The new starting mean MatchmakingService : SetStartingMean ( newStartingMean )","title":"Setting the Starting Ranking Mean"},{"location":"maindocs/#setting-the-starting-ranking-standard-deviation","text":"Sets the starting standard deviation of OpenSkill objects. Warning Do not modify this unless you know what you're doing. Parameter Name Type Description Default Value newStartingStandardDeviation number The new starting standing deviation MatchmakingService : SetStartingStandardDeviation ( newStartingStandardDeviation )","title":"Setting the Starting Ranking Standard Deviation"},{"location":"maindocs/#setting-the-max-skill-gap-between-party-members","text":"Sets the max gap in rating between party members. Parameter Name Type Description Default Value newMaxGap number The new max gap between party members MatchmakingService : SetMaxPartySkillGap ( newMaxGap )","title":"Setting the Max Skill Gap Between Party Members"},{"location":"maindocs/#obtaining-a-rating-value-from-an-openskill-object","text":"Turns an OpenSkill object into a single rating number. Parameter Name Type Description Default Value openSkillObject OpenSkill object The OpenSkill object MatchmakingService : ToRatingNumber ( openSkillObject ) Returns Type Description number The single number representation of the object","title":"Obtaining a Rating Value from an OpenSkill Object"},{"location":"maindocs/#obtaining-an-openskill-object","text":"Gets or initializes a players OpenSkill object. Note You should not edit this directly unless you know what you're doing. Parameter Name Type Description Default Value player Player The player to get the OpenSkill object of ratingType string The rating type to get MatchmakingService : GetPlayerRating ( player , ratingType ) Returns Type Description OpenSkill object The OpenSkill object (which is just 2 numbers)","title":"Obtaining an OpenSkill Object"},{"location":"maindocs/#setting-an-openskill-object","text":"Sets a player's skill. Note You should not edit this directly unless you know what you're doing. Parameter Name Type Description Default Value player Player The player to get the OpenSkill object of ratingType string The rating type to get rating OpenSkill object The new OpenSkill object MatchmakingService : SetPlayerRating ( player , ratingType , rating )","title":"Setting an OpenSkill Object"},{"location":"maindocs/#clearing-a-players-info","text":"Clears the player info. Parameter Name Type Description Default Value player Player The player to clear MatchmakingService : ClearPlayerInfo ( player )","title":"Clearing a Player's Info"},{"location":"maindocs/#setting-a-players-info","text":"Sets the player info. Parameter Name Type Description Default Value player Player The player to update code string The game id that the player will teleport to, if any ratingType string The rating type of their current game, if any party table The player's party (table of user ids including the player) map string The player's queued map, if any MatchmakingService : SetPlayerInfo ( player , code , ratingType , party , map )","title":"Setting a Player's info"},{"location":"maindocs/#getting-a-players-info","text":"Gets the player info. Parameter Name Type Description Default Value player Player The player to get MatchmakingService : GetPlayerInfo ( player ) Returns Type Description table or nil The player info","title":"Getting a Player's Info"},{"location":"maindocs/#getting-the-queue","text":"Gets a table of user ids, ratingTypes, and skillLevels in a specific queue. Parameter Name Type Description Default Value map string The map to get the queue of MatchmakingService : GetQueue ( map ) Returns Type Description table A dictionary of {ratingType: {skillLevel: queue}} where ratingType is the rating type, skillLevel is the skill level pool (a rounded rating), and queue is a table of user ids","title":"Getting the Queue"},{"location":"maindocs/#queueing-a-single-player","text":"Queues a player. Parameter Name Type Description Default Value player Player The player to queue ratingType string The rating type to use map string The map to queue them on MatchmakingService : QueuePlayer ( player , ratingType , map ) Returns Type Description boolean A boolean that is true if the player was queued","title":"Queueing a Single Player"},{"location":"maindocs/#queueing-a-party","text":"Queues a party. Parameter Name Type Description Default Value players table<\u200bPlayer> The players to queue ratingType string The rating type to use map string The map to queue them on MatchmakingService : QueueParty ( players , ratingType , map ) Returns Type Description boolean A boolean that is true if the party was queued Player The player that caused the queue to not start string The reason the queue did not start","title":"Queueing a Party"},{"location":"maindocs/#getting-a-players-party","text":"Gets a player's party. Parameter Name Type Description Default Value player Player The player to get the party of MatchmakingService : GetPlayerParty ( player ) Returns Type Description table<\u200bstring> A table of player id's of players in the party including this player","title":"Getting a Player's Party"},{"location":"maindocs/#remove-a-single-player-from-the-queue","text":"Removes a specific player from the queue. Parameter Name Type Description Default Value player Player The player to remove from queue MatchmakingService : RemovePlayerFromQueue ( player ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Remove a Single Player from the Queue"},{"location":"maindocs/#remove-multiple-players-from-the-queue","text":"Removes a table of players from the queue. Parameter Name Type Description Default Value players table<\u200bPlayer> The players to remove from queue MatchmakingService : RemovePlayersFromQueue ( players ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Remove Multiple Players from the Queue"},{"location":"maindocs/#adding-a-player-to-an-existing-game","text":"Adds a player to a specific existing game. Parameter Name Type Description Default Value player Player The player to add to the game gameId string The id of the game to add the player to updateJoinable boolean Whether or not to update the joinable status of the game MatchmakingService : AddPlayerToGame ( player , gameId , updateJoinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Adding A Player to an Existing Game"},{"location":"maindocs/#adding-multiple-players-to-an-existing-game","text":"Adds a table of players to a specific existing game. Parameter Name Type Description Default Value player table<\u200bPlayer> The players to add to the game gameId string The id of the game to add the player to updateJoinable boolean Whether or not to update the joinable status of the game MatchmakingService : AddPlayersToGame ( players , gameId , updateJoinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Adding Multiple Players to an Existing Game"},{"location":"maindocs/#removing-a-player-from-a-game","text":"Removes a specific player from an existing game. Parameter Name Type Description Default Value player Player The player to remove from the game gameId string The id of the game to remove the player from updateJoinable boolean Whether or not to update the joinable status of the game MatchmakingService : RemovePlayersFromGame ( players , gameId , updateJoinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Removing a Player from a Game"},{"location":"maindocs/#updating-ratings","text":"Update player ratings after a game is over. Parameter Name Type Description Default Value ratingType string The rating type this is applicable for ranks table<\u200bnumber> The ranks of the teams. #scores should be the same as the #teams teams table<\u200bPlayer> The teams. A table of tables which contain players MatchmakingService : UpdateRatings ( ratingType , ranks , teams ) Explaination Basically, lets have this scenario in the ratingType ranked: local team1 = { player1 , player2 } local team2 = { player3 , player4 } local team3 = { player5 , player6 } Let\u2019s say team2 came first, team1 came second and team3 came third. To update the ratings correctly, you would do this: MatchmakingService:UpdateRatings(\"ranked\", {2, 1, 3}, {team1, team2, team3}) {2,1,3} is important, and so is order. Order is extremely important here. Because I passed the teams in order, I can give the position of each team in order. As previously stated team1 placed second, therefore because team1 is the first team in the teams table, it also has the first value in the rankings table. Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Updating Ratings"},{"location":"maindocs/#set-the-games-joinable-status","text":"Sets the joinable status of a game. Parameter Name Type Description Default Value gameId string The id of the game to update joinable boolean Whether or not the game will be joinable MatchmakingService : SetJoinable ( gameId , joinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Set the Game's Joinable Status"},{"location":"maindocs/#remove-a-game-from-memory","text":"Removes a game from memory. Parameter Name Type Description Default Value gameId string The game to remove MatchmakingService : RemoveGame ( gameId ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Remove a Game from Memory"},{"location":"maindocs/#start-a-game","text":"Starts a game. Parameter Name Type Description Default Value gameId string The game to start joinable boolean Whether or not the game is still joinable MatchmakingService : StartGame ( gameId , joinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Start a Game"}]}