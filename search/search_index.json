{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Matchmaking Service What is it? Matchmaking Service is an attempt to bring cross-server matchmaking with built in skill-based matchmaking (if you want to use it). Utilizing the new Memory Store Service for fast-based high throughput potentital, Matchmaking Service will keep up even with bigger games. Matchmaking Service is made to be easy to use. It exposes a fully documented API to developers so they can enjoy the sweet, sweet theory of programming abstraction. However, if you're interested in the guts of the program, it is fully open source and available on our github . That means you can keep up to date with its development and even contribute, open issues, and request new features all in one place. This makes it easy for our contributors to keep track of everything as well. Skill-based matchmaking? Matchmaking Service provides built in skill-based matchmaking using a luau OpenSkill implementation (which you can find here ). This means that your players won't have to deal with going against opponents they have no chance at beating and it means that you can provide your players with the amazing rank up feeling... if you choose. Of course because not everybody likes skill-based matchmaking, it is completely optional. You can disable it as well. If you disable it, anywhere you would normally pass a ratingType , just pass nil . Getting started Check out our getting started page for more information on how basic implementation of this system works. Getting a specific major version Major versions have breaking changes. Because of this, we've added a way to get a specific major version. When using GetSingleton() , you can pass an options table. One of these options is MajorVersion . This will ensure that you don't automatically update to a version with a breaking change. Previous major versions will usually not be updated, so it's recommended to update to the latest version when you have time. Current allowed values: \"v1\" \"v2\" Example: local MatchmakingService = require(7567983240).GetSingleton({[\"MajorVersion\"]=\"v1\"}) Quick fix for many issues If you encounter an issue, it is best to first note the issue, take a screenshot of any errors and send it to me in a private message on devforum. To quickly fix issues that pop up, just clear the memory. Open your game in roblox (not studio) Press F9 to open the console and navigate to the server logs In the command line type require(7567983240).GetSingleton():Clear() Shutdown all running servers to restart your game This is just a quick fix for many issues that pop up. It might not always work, but if I can't fix the issue at the time, it's a good place to start.","title":"Home"},{"location":"#matchmaking-service","text":"","title":"Matchmaking Service"},{"location":"#what-is-it","text":"Matchmaking Service is an attempt to bring cross-server matchmaking with built in skill-based matchmaking (if you want to use it). Utilizing the new Memory Store Service for fast-based high throughput potentital, Matchmaking Service will keep up even with bigger games. Matchmaking Service is made to be easy to use. It exposes a fully documented API to developers so they can enjoy the sweet, sweet theory of programming abstraction. However, if you're interested in the guts of the program, it is fully open source and available on our github . That means you can keep up to date with its development and even contribute, open issues, and request new features all in one place. This makes it easy for our contributors to keep track of everything as well.","title":"What is it?"},{"location":"#skill-based-matchmaking","text":"Matchmaking Service provides built in skill-based matchmaking using a luau OpenSkill implementation (which you can find here ). This means that your players won't have to deal with going against opponents they have no chance at beating and it means that you can provide your players with the amazing rank up feeling... if you choose. Of course because not everybody likes skill-based matchmaking, it is completely optional. You can disable it as well. If you disable it, anywhere you would normally pass a ratingType , just pass nil .","title":"Skill-based matchmaking?"},{"location":"#getting-started","text":"Check out our getting started page for more information on how basic implementation of this system works.","title":"Getting started"},{"location":"#getting-a-specific-major-version","text":"Major versions have breaking changes. Because of this, we've added a way to get a specific major version. When using GetSingleton() , you can pass an options table. One of these options is MajorVersion . This will ensure that you don't automatically update to a version with a breaking change. Previous major versions will usually not be updated, so it's recommended to update to the latest version when you have time. Current allowed values: \"v1\" \"v2\" Example: local MatchmakingService = require(7567983240).GetSingleton({[\"MajorVersion\"]=\"v1\"})","title":"Getting a specific major version"},{"location":"#quick-fix-for-many-issues","text":"If you encounter an issue, it is best to first note the issue, take a screenshot of any errors and send it to me in a private message on devforum. To quickly fix issues that pop up, just clear the memory. Open your game in roblox (not studio) Press F9 to open the console and navigate to the server logs In the command line type require(7567983240).GetSingleton():Clear() Shutdown all running servers to restart your game This is just a quick fix for many issues that pop up. It might not always work, but if I can't fix the issue at the time, it's a good place to start.","title":"Quick fix for many issues"},{"location":"faq/","text":"Frequently Asked Questions How do I make parties with Matchmaking Service? MMS does not handle party creation for you. All MMS does is ensure players queued as a group will get into the same game. You can queue a party using QueueParty(players, ratingType, map) and you can retrieve a user's party by using GetPlayerParty(player) . What does ______ error mean? Most of the time, I wouldn't know without doing some experimenting. However, there is an error which you may run into which I have no control over. When you see MainModule:line: Request Failed. that means that the Memory Store rejected the request, which usually means it's experiencing disruptions. Make sure to check the ropblox status to see if there's a service disruption. Other errors that you may see: The rate of requests exceeds the allowed limit . If you see this, you're making more than 1000 + 100 * (active players across entire game universe) requests to the memory stores per minute. This usually shouldn't happen, but it could happen if you have a player spamming more than 50 queue and unqueue requests per minute (1 request to add them, 1 request to remove them and each player adds 100 to the limit), but it'd be nearly impossible to take up the whole limit like this because of how many requests you get per user. It'd most likely need to be a targeted attack to break your game. I recommend adding a rate limit to how fast your players can queue and unqueue. Failed to invoke transformation function . If you see this report it to me asap with as much detail as you can give. It means one of the update functions didn't return as expected and could impact many users of MMS. Code: 4, Error: The provided value is too long . If you see this, then it usually means you had, on average, more than 100 players queueing for the same map and rating type in the same second. This error happens due to the 1kb size limit (I'm currently in talks with roblox to increase this limit. If it doesn't increase I'll add a way to break the queue so this doesn't happen). Technical details of MMS Some people ask me technical details of matchmaking service. Don't be afraid to send me questions if you're interested in how the service works!","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"How do I make parties with Matchmaking Service? MMS does not handle party creation for you. All MMS does is ensure players queued as a group will get into the same game. You can queue a party using QueueParty(players, ratingType, map) and you can retrieve a user's party by using GetPlayerParty(player) . What does ______ error mean? Most of the time, I wouldn't know without doing some experimenting. However, there is an error which you may run into which I have no control over. When you see MainModule:line: Request Failed. that means that the Memory Store rejected the request, which usually means it's experiencing disruptions. Make sure to check the ropblox status to see if there's a service disruption. Other errors that you may see: The rate of requests exceeds the allowed limit . If you see this, you're making more than 1000 + 100 * (active players across entire game universe) requests to the memory stores per minute. This usually shouldn't happen, but it could happen if you have a player spamming more than 50 queue and unqueue requests per minute (1 request to add them, 1 request to remove them and each player adds 100 to the limit), but it'd be nearly impossible to take up the whole limit like this because of how many requests you get per user. It'd most likely need to be a targeted attack to break your game. I recommend adding a rate limit to how fast your players can queue and unqueue. Failed to invoke transformation function . If you see this report it to me asap with as much detail as you can give. It means one of the update functions didn't return as expected and could impact many users of MMS. Code: 4, Error: The provided value is too long . If you see this, then it usually means you had, on average, more than 100 players queueing for the same map and rating type in the same second. This error happens due to the 1kb size limit (I'm currently in talks with roblox to increase this limit. If it doesn't increase I'll add a way to break the queue so this doesn't happen). Technical details of MMS Some people ask me technical details of matchmaking service. Don't be afraid to send me questions if you're interested in how the service works!","title":"Frequently Asked Questions"},{"location":"gettingstarted/","text":"Getting Started Getting the module While I personally recommend requiring the module directly by id to stay up to date, there are a number of reasons why you may choose to not do this. For this reason the module itself is available to add to your roblox inventory here . Preface Matchmaking Service requires at least 2 games in a single universe to work. We call these hub servers and instance servers. Your hub servers are responsible for adding players to queues. Your instance servers are where the actual game will take place, this is where you want all of your game logic to go. We'll be starting off with the basic hub server logic. Matchmaking Service currently utilizes a central server to handle all matchmaking. We are looking into ways to distributing this and having a fully decentralized hub for performance, but no great solution has been found. For this reason I do not recommend having 1 player max hub servers as that means it's constantly switching central servers which is less than ideal. Hub logic Obtaining the MatchmakingService Singleton Matchmaking Service utilizes a top-level singleton. This means every time you require it and invoke GetSingleton in the same server the same singleton is returned. Getting this singleton is really simple: local MatchmakingService = require ( 7567983240 ). GetSingleton () -- You may opt to use a direct path to it if you don't want to require by id Setting the instance server As said in the preface, Matchmaking Service uses hub servers and instance servers. Instance servers are your game servers. They are the place players are teleported to when a match is found. For this step you will need the place id of your instance server. This is simple to obtain. First, open the instance server's place in studio. Then in your console type print(game.PlaceId) . The result is the place id that you will need for this step. Alternatively, use the asset manager and right click on the place and \"Copy ID to clipboard\": local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : AddGamePlace ( \"Map Name\" , placeIdYouCopied ) -- Instance and hub servers must exist in the same universe And believe it or not, that's it. That is the most basic implementation of a hub server without changing any of the values. Setting the player range The player range controls the min and max players for a game. If you think about many other multiplayer games, the game might start while the server is not full or it might want to wait for a full server to move players into the game. Using NumberRanges makes this functionality easy. local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : SetPlayerRange ( \"Map Name\" , NumberRange . new ( 5 , 10 )) What this does is tells the queue to teleport players to the instance server when there are at least 5, but allows new players to be added to the game until there are 10. Queueing players Queueing players is simple, you can do this from a gui remote event, on join or anywhere (from the server): local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : QueuePlayer ( p , \"unranked\" , \"Map Name\" ) This will queue a player into the unranked lobby (note, just because it's unranked does not mean it's not rated. All rank types will have a rating attached to them, but it's up to you whether you want to update it or not). This means they will only search for other players in the same lobby. There are no huge limits on this, except I recommend to keep the size under 20 characters. Queueing parties Matchmaking Service provides an easy way to queue multiple players at the same time and ensure they get into the same game. However, Matchmaking Service will not handle forming parties or ensuring they're on the same team in instance servers, that is something you will have to do. local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : QueueParty ( players , \"unranked\" , \"Map Name\" ) -- Players is a table of player objects When you do this, they will be guaranteed to get into the same server. Removing single players from the queue By default, Matchmaking Service will handle removing players from the queue when they get into a game or leave the hub. However, you may want to give them the option to remove themselves from queue, so Matchmaking Service exposes a method for this: local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : RemovePlayerFromQueue ( player ) This will remove them from the queue, no matter what lobby they're in. If they are not queued, then this will do nothing. Removing multiple players from the queue Removing multiple players from the queue at the same time is helpful to drastically reduce the number of calls to memory, which means lower chance of hitting the cap and breaking the system. This is also the easiest way to remove parties from the queue. local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : RemovePlayersFromQueue ( players ) --- Players is a table of player objects Note: This function is more efficient on memory updates if all of the users are in the same lobby type, however it is not required. Instance server logic Instance servers are also simple. This section will go over the most basic instance server implementation and everything that is required to make it work. Denoating a server as a game instance It's important to denote a server as a game instance as this removes the ability for it to become the central server, and removes logic that may impact game performance. You should set the player range to match that of the hub server You can choose to set the field directly, but I recommend that you use the built in method in case anything changes in the future: local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : SetIsGameServer ( true ) MatchmakingService : SetPlayerRange ( \"Map 1\" , NumberRange . new ( 2 , 2 )) Obtaining game data Data about the match is kept in the memory store. This prevents players from messing with teleport data. I recommend doing this right in player join, but you could theoretically do it at any time you'd like. However, I do recommend that you only do this call once as to prevent additional calls to memory. Ideally you should call it once and then cache it. game . Players . PlayerAdded : Connect ( function ( player ) local gameData = MatchmakingService : GetGameData () -- do whatever end ) Starting the game Starting the game is important because it tells the queue manager that the game is started, you can also pass a boolean value that determines whether or not the game is joinable still. By default the game will not be joinable if no value is passed. function Start () -- Start the game, but allow new joiners MatchmakingService : StartGame ( gameData . gameCode , true ) end Manually removing a player from a game You may manually remove players from games when they leave to open up spots for new players in games. You can do that with the following script. Note: for this to work properly, the player range in the hub server and instance server must match. game . Players . PlayerRemoving : Connect ( function ( player ) MatchmakingService : RemovePlayerFromGame ( player , gameData . gameCode ) end ) Updating rating As noted previously, Matchmaking Service has a built in rating system. If you want to use it, you'll have to manually invoke the UpdateRatings function. If you don't invoke this function, the players' rating will never change and it'll be essentially the same as having no rating at all. Updating rating must be done before BindToClose . This means that you will need your own end game functionality. This script is an example of one way you may choose to implement this functionality: function EndGame ( winner ) MatchmakingService : UpdateRatings ( gameData . ratingType , { 2 , 1 , 3 }, { team1 , team2 , team3 }) for i , v in ipairs ( game . Players : GetPlayers ()) do -- You can teleport them back to the hub here, I just kick them v : Kick () end end The line we'll be focusing on is as follows: MatchmakingService : UpdateRatings ( gameData . ratingType , { 2 , 1 , 3 }, { team1 , team2 , team3 }) - gameData.ratingType is the rating type they queued for. This is passed in teleport data - {2, 1, 3} is the positional placements of each team (order is important, rankings[1] is paired to teams[1] ). Lower is better. 1 means first place, 2 is second and so on. This supports any number of rankings, but it must match the number of teams. - {team1, team2, team3} are the teams themselves. Each team is a table of players on that team (even if there is only 1 player, it must be in a table). The order is important as they are paired to the same index as their ranking. That's really it for server instances. The only things you are required to do for a smooth experience is denoting the server as a game server and removing the game on close. Updating ratings is optional. Full example scripts Extremely basic 1v1 game hub server: -- Obtain the service local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : SetPlayerRange ( \"Map 1\" , NumberRange . new ( 2 , 2 )) -- 2, 2 means min players 2, max players 2 (or 1v1) -- Set the game place, this game must exist in the same universe MatchmakingService : AddGamePlace ( \"Map 1\" , gamePlaceIdHere ) -- Queue players (you can call QueuePlayer from anywhere) game . Players . PlayerAdded : Connect ( function ( p ) MatchmakingService : QueuePlayer ( p , \"queue\" , \"Map 1\" ) -- \"queue\" can be any string you want, so can the map end ) for i , p in ipairs ( game . Players : GetPlayers ()) do MatchmakingService : QueuePlayer ( p , \"queue\" , \"Map 1\" ) -- \"queue\" can be any string you want, so can the map end Extremely basic 1v1 game instance server (EndGame is not called in this example): local MatchmakingService = require ( 7567983240 ). GetSingleton () -- It's important game servers know how large they can get. You don't really need every map here, -- but you do need whichever map this is. MatchmakingService : SetPlayerRange ( \"Map 1\" , NumberRange . new ( 2 , 2 )) -- Tell the service this is a game server MatchmakingService : SetIsGameServer ( true ) local gameData = nil local t1 = {} local t2 = {} -- Basic start function function Start () print ( \"Started\" ) MatchmakingService : StartGame ( gameData . gameCode ) -- Simple teams for a 1v1. local p = game . Players : GetPlayers () table.insert ( t1 , p [ 1 ]) table.insert ( t2 , p [ 2 ]) end -- YOU MUST CALL UpdateRatings BEFORE THE GAME IS CLOSED. YOU CANNOT PUT THIS IN BindToClose! function EndGame ( winner ) MatchmakingService : UpdateRatings ( gameData . ratingType , { if winner == 1 then 1 else 2 , if winner == 2 then 1 , else 2 }, { t1 , t2 }) for i , v in ipairs ( game . Players : GetPlayers ()) do -- You can teleport them back to the hub here, I just kick them v : Kick () end end game . Players . PlayerAdded : Connect ( function ( player ) if not gameData then gameData = MatchmakingService : GetGameData () end if # game . Players : GetPlayers () >= 2 then Start () end end ) Conclusion As you can see, with under 50 lines of code, you can have fully functional cross-server match making. This is just the tip of the iceberg with Matchmaking Service as well. For more in-depth documentation see the main docs . If you encounter any issues don't hesitate to open an issue . If you need assistance, feel free to contact me on dev forum.","title":"Getting Started"},{"location":"gettingstarted/#getting-started","text":"","title":"Getting Started"},{"location":"gettingstarted/#getting-the-module","text":"While I personally recommend requiring the module directly by id to stay up to date, there are a number of reasons why you may choose to not do this. For this reason the module itself is available to add to your roblox inventory here .","title":"Getting the module"},{"location":"gettingstarted/#preface","text":"Matchmaking Service requires at least 2 games in a single universe to work. We call these hub servers and instance servers. Your hub servers are responsible for adding players to queues. Your instance servers are where the actual game will take place, this is where you want all of your game logic to go. We'll be starting off with the basic hub server logic. Matchmaking Service currently utilizes a central server to handle all matchmaking. We are looking into ways to distributing this and having a fully decentralized hub for performance, but no great solution has been found. For this reason I do not recommend having 1 player max hub servers as that means it's constantly switching central servers which is less than ideal.","title":"Preface"},{"location":"gettingstarted/#hub-logic","text":"","title":"Hub logic"},{"location":"gettingstarted/#obtaining-the-matchmakingservice-singleton","text":"Matchmaking Service utilizes a top-level singleton. This means every time you require it and invoke GetSingleton in the same server the same singleton is returned. Getting this singleton is really simple: local MatchmakingService = require ( 7567983240 ). GetSingleton () -- You may opt to use a direct path to it if you don't want to require by id","title":"Obtaining the MatchmakingService Singleton"},{"location":"gettingstarted/#setting-the-instance-server","text":"As said in the preface, Matchmaking Service uses hub servers and instance servers. Instance servers are your game servers. They are the place players are teleported to when a match is found. For this step you will need the place id of your instance server. This is simple to obtain. First, open the instance server's place in studio. Then in your console type print(game.PlaceId) . The result is the place id that you will need for this step. Alternatively, use the asset manager and right click on the place and \"Copy ID to clipboard\": local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : AddGamePlace ( \"Map Name\" , placeIdYouCopied ) -- Instance and hub servers must exist in the same universe And believe it or not, that's it. That is the most basic implementation of a hub server without changing any of the values.","title":"Setting the instance server"},{"location":"gettingstarted/#setting-the-player-range","text":"The player range controls the min and max players for a game. If you think about many other multiplayer games, the game might start while the server is not full or it might want to wait for a full server to move players into the game. Using NumberRanges makes this functionality easy. local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : SetPlayerRange ( \"Map Name\" , NumberRange . new ( 5 , 10 )) What this does is tells the queue to teleport players to the instance server when there are at least 5, but allows new players to be added to the game until there are 10.","title":"Setting the player range"},{"location":"gettingstarted/#queueing-players","text":"Queueing players is simple, you can do this from a gui remote event, on join or anywhere (from the server): local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : QueuePlayer ( p , \"unranked\" , \"Map Name\" ) This will queue a player into the unranked lobby (note, just because it's unranked does not mean it's not rated. All rank types will have a rating attached to them, but it's up to you whether you want to update it or not). This means they will only search for other players in the same lobby. There are no huge limits on this, except I recommend to keep the size under 20 characters.","title":"Queueing players"},{"location":"gettingstarted/#queueing-parties","text":"Matchmaking Service provides an easy way to queue multiple players at the same time and ensure they get into the same game. However, Matchmaking Service will not handle forming parties or ensuring they're on the same team in instance servers, that is something you will have to do. local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : QueueParty ( players , \"unranked\" , \"Map Name\" ) -- Players is a table of player objects When you do this, they will be guaranteed to get into the same server.","title":"Queueing parties"},{"location":"gettingstarted/#removing-single-players-from-the-queue","text":"By default, Matchmaking Service will handle removing players from the queue when they get into a game or leave the hub. However, you may want to give them the option to remove themselves from queue, so Matchmaking Service exposes a method for this: local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : RemovePlayerFromQueue ( player ) This will remove them from the queue, no matter what lobby they're in. If they are not queued, then this will do nothing.","title":"Removing single players from the queue"},{"location":"gettingstarted/#removing-multiple-players-from-the-queue","text":"Removing multiple players from the queue at the same time is helpful to drastically reduce the number of calls to memory, which means lower chance of hitting the cap and breaking the system. This is also the easiest way to remove parties from the queue. local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : RemovePlayersFromQueue ( players ) --- Players is a table of player objects Note: This function is more efficient on memory updates if all of the users are in the same lobby type, however it is not required.","title":"Removing multiple players from the queue"},{"location":"gettingstarted/#instance-server-logic","text":"Instance servers are also simple. This section will go over the most basic instance server implementation and everything that is required to make it work.","title":"Instance server logic"},{"location":"gettingstarted/#denoating-a-server-as-a-game-instance","text":"It's important to denote a server as a game instance as this removes the ability for it to become the central server, and removes logic that may impact game performance. You should set the player range to match that of the hub server You can choose to set the field directly, but I recommend that you use the built in method in case anything changes in the future: local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : SetIsGameServer ( true ) MatchmakingService : SetPlayerRange ( \"Map 1\" , NumberRange . new ( 2 , 2 ))","title":"Denoating a server as a game instance"},{"location":"gettingstarted/#obtaining-game-data","text":"Data about the match is kept in the memory store. This prevents players from messing with teleport data. I recommend doing this right in player join, but you could theoretically do it at any time you'd like. However, I do recommend that you only do this call once as to prevent additional calls to memory. Ideally you should call it once and then cache it. game . Players . PlayerAdded : Connect ( function ( player ) local gameData = MatchmakingService : GetGameData () -- do whatever end )","title":"Obtaining game data"},{"location":"gettingstarted/#starting-the-game","text":"Starting the game is important because it tells the queue manager that the game is started, you can also pass a boolean value that determines whether or not the game is joinable still. By default the game will not be joinable if no value is passed. function Start () -- Start the game, but allow new joiners MatchmakingService : StartGame ( gameData . gameCode , true ) end","title":"Starting the game"},{"location":"gettingstarted/#manually-removing-a-player-from-a-game","text":"You may manually remove players from games when they leave to open up spots for new players in games. You can do that with the following script. Note: for this to work properly, the player range in the hub server and instance server must match. game . Players . PlayerRemoving : Connect ( function ( player ) MatchmakingService : RemovePlayerFromGame ( player , gameData . gameCode ) end )","title":"Manually removing a player from a game"},{"location":"gettingstarted/#updating-rating","text":"As noted previously, Matchmaking Service has a built in rating system. If you want to use it, you'll have to manually invoke the UpdateRatings function. If you don't invoke this function, the players' rating will never change and it'll be essentially the same as having no rating at all. Updating rating must be done before BindToClose . This means that you will need your own end game functionality. This script is an example of one way you may choose to implement this functionality: function EndGame ( winner ) MatchmakingService : UpdateRatings ( gameData . ratingType , { 2 , 1 , 3 }, { team1 , team2 , team3 }) for i , v in ipairs ( game . Players : GetPlayers ()) do -- You can teleport them back to the hub here, I just kick them v : Kick () end end The line we'll be focusing on is as follows: MatchmakingService : UpdateRatings ( gameData . ratingType , { 2 , 1 , 3 }, { team1 , team2 , team3 }) - gameData.ratingType is the rating type they queued for. This is passed in teleport data - {2, 1, 3} is the positional placements of each team (order is important, rankings[1] is paired to teams[1] ). Lower is better. 1 means first place, 2 is second and so on. This supports any number of rankings, but it must match the number of teams. - {team1, team2, team3} are the teams themselves. Each team is a table of players on that team (even if there is only 1 player, it must be in a table). The order is important as they are paired to the same index as their ranking. That's really it for server instances. The only things you are required to do for a smooth experience is denoting the server as a game server and removing the game on close. Updating ratings is optional.","title":"Updating rating"},{"location":"gettingstarted/#full-example-scripts","text":"Extremely basic 1v1 game hub server: -- Obtain the service local MatchmakingService = require ( 7567983240 ). GetSingleton () MatchmakingService : SetPlayerRange ( \"Map 1\" , NumberRange . new ( 2 , 2 )) -- 2, 2 means min players 2, max players 2 (or 1v1) -- Set the game place, this game must exist in the same universe MatchmakingService : AddGamePlace ( \"Map 1\" , gamePlaceIdHere ) -- Queue players (you can call QueuePlayer from anywhere) game . Players . PlayerAdded : Connect ( function ( p ) MatchmakingService : QueuePlayer ( p , \"queue\" , \"Map 1\" ) -- \"queue\" can be any string you want, so can the map end ) for i , p in ipairs ( game . Players : GetPlayers ()) do MatchmakingService : QueuePlayer ( p , \"queue\" , \"Map 1\" ) -- \"queue\" can be any string you want, so can the map end Extremely basic 1v1 game instance server (EndGame is not called in this example): local MatchmakingService = require ( 7567983240 ). GetSingleton () -- It's important game servers know how large they can get. You don't really need every map here, -- but you do need whichever map this is. MatchmakingService : SetPlayerRange ( \"Map 1\" , NumberRange . new ( 2 , 2 )) -- Tell the service this is a game server MatchmakingService : SetIsGameServer ( true ) local gameData = nil local t1 = {} local t2 = {} -- Basic start function function Start () print ( \"Started\" ) MatchmakingService : StartGame ( gameData . gameCode ) -- Simple teams for a 1v1. local p = game . Players : GetPlayers () table.insert ( t1 , p [ 1 ]) table.insert ( t2 , p [ 2 ]) end -- YOU MUST CALL UpdateRatings BEFORE THE GAME IS CLOSED. YOU CANNOT PUT THIS IN BindToClose! function EndGame ( winner ) MatchmakingService : UpdateRatings ( gameData . ratingType , { if winner == 1 then 1 else 2 , if winner == 2 then 1 , else 2 }, { t1 , t2 }) for i , v in ipairs ( game . Players : GetPlayers ()) do -- You can teleport them back to the hub here, I just kick them v : Kick () end end game . Players . PlayerAdded : Connect ( function ( player ) if not gameData then gameData = MatchmakingService : GetGameData () end if # game . Players : GetPlayers () >= 2 then Start () end end )","title":"Full example scripts"},{"location":"gettingstarted/#conclusion","text":"As you can see, with under 50 lines of code, you can have fully functional cross-server match making. This is just the tip of the iceberg with Matchmaking Service as well. For more in-depth documentation see the main docs . If you encounter any issues don't hesitate to open an issue . If you need assistance, feel free to contact me on dev forum.","title":"Conclusion"},{"location":"maindocs/","text":"Preface This documentation will provide the insight on to every method available from Matchmaking Service. This will include methods intended for internal use, these are still documented, just in case you ever need them. Note Every method here that involves a player object most likely also has an \"Id\" variant. Internally, everything is done with user ids, but the helper methods exist to streamline the process. This means if you see a method called RemovePlayersFromGame , there is another method called RemovePlayersFromGameId where instead of player objects, user ids are passed. If you're in doubt whether or not an id variant exists for the method you are using, I recommend looking through the source , if it exists, it will have the same name suffixed with Id . \"Id\" variants will not be listed here unless there is no regular variant. Obtaining Singleton Gets or creates the top level singleton of the matchmaking service. Parameter Name Type Description Default Value options table The options to provide matchmaking service {} options.MajorVersion string The major version to use nil options.DisableRatingSystem boolean Whether or not to disable the rating system false options.DisableExpansions boolean Whether or not to disable expansions false options.DisableGlobalEvents boolean Whether or not to disable global events false MatchmakingService . GetSingleton ( options ) Returns Type Description MatchmakingService The matchmaking service singleton Clearing the Memory Clears all memory aside from player data. MatchmakingService : Clear () Listening for Players Being Added to Queue You can listen to players being added to the queue globally. This will fire in waves when coming from other servers. This is a signal, so you need to connect to it. Below is a table of what it passes, in order. Type Description number The player's UserId string The map the player queued for string The rating type the player queued for number The rounded rating value of the player. CAN BE NIL Connecting to the listener is simple: MatchmakingService . PlayerAddedToQueue : Connect ( function ( player , map , ratingType , roundedRating ) print ( player , map , ratingType , roundedRating ) end ) Listening for Players Being Removed from the Queue You can listen to players being removed from the queue globally. This will fire in waves when coming from other servers. This is a signal, so you need to connect to it. Below is a table of what it passes, in order. Type Description number The player's UserId string The map the player queued for string The rating type the player queued for number The rounded rating value of the player. CAN BE NIL Connecting to the listener is simple: MatchmakingService . PlayerRemovedFromQueue : Connect ( function ( player , map , ratingType , roundedRating ) print ( player , map , ratingType , roundedRating ) end ) Listening for Finding Games You can listen for when players find games. This signal is not global. Below is a table of what it passes, in order. Type Description number The player's UserId string The unique code which identifies the game table The game data MatchmakingService . FoundGame : Connect ( function ( player , gameCode , gameData ) print ( player , gameCode , gameData ) end ) Applying Custom Teleport Data to Players You can apply custom teleport data to players to access it in the game when they are teleported. This is a function that you can bind to. You may only bind to it once. Below is a table of what it passes, in order. This function can return anything, but some things won't be replicated to other servers. Metatables and instances will not be passed correctly. This should mainly return strings and numbers, or a table of them so that you can reconstruct instances on the server, or just obtain general data that you need in the game. Type Description Player The Player table The game data You can bind this function like so: MatchmakingService . ApplyCustomTeleportData = function ( player , gameData ) return {[ \"Some\" ] = \"Custom\" ,[ \"Data\" ] = \"Table\" } end To retrieve it on the instance server where players are teleported to, you'll need to do something like this: game . Players . PlayerAdded : Connect ( function ( player ) local playerData = MatchmakingService : GetUserData ( player ) print ( playerData ) end ) The user id is passed as a string (this is out of our control, it is converted to a string when passed), so you must use tostring on player.UserId to properly get their data. Applying Custom Teleport Data to the Game You can apply custom teleport data to the game overall (which may be conditional). This is a function that you can bind to. You may only bind to it once. Below is a table of what it passes, in order. This function can return anything, but some things won't be replicated to other servers. Metatables and instances will not be passed correctly. This should mainly return strings and numbers, or a table of them so that you can reconstruct instances on the server, or just obtain general data that you need in the game. Type Description table The game data You can bind this function like so: MatchmakingService . ApplyGeneralTeleportData = function ( gameData ) return {[ \"Some\" ] = \"Custom\" ,[ \"Data\" ] = \"Table\" } end To retrieve it on the instance server where players are teleported to, you'll need to do something like this: game . Players . PlayerAdded : Connect ( function ( player ) local gameData = MatchmakingService : GetGameData () -- gets the current game's data, includes custom data print ( gameData ) end ) The user id is passed as a string (this is out of our control, it is converted to a string when passed), so you must use tostring on player.UserId to properly get their data. Setting Matchmaking Interval Sets the matchmaking interval. Parameter Name Type Description Default Value newInterval number The new matchmaking interval MatchmakingService : SetMatchmakingInterval ( newInterval ) Setting the Player Range Sets the min/max players. Parameter Name Type Description Default Value map string The map the player range applies to newPlayerRange number The NumberRange with the min and max players MatchmakingService : SetPlayerRange ( map , newPlayerRange ) Adding A New Map Add a new game place. Parameter Name Type Description Default Value name string The name of the map id number The place id to teleport to MatchmakingService : AddGamePlace ( name , id ) Seting Is Game Server Sets whether or not this is a game server. Note Disables match finding coroutine if newValue is true. Parameter Name Type Description Default Value newValue boolean A boolean that indicates whether or not this server is a game server updateJoinableOnLeave boolean A boolean that indicates whether or not to update the joinable status when a player leaves MatchmakingService : SetIsGameServer ( newValue , updateJoinableOnLeave ) Setting the Starting Ranking Mean Sets the starting mean of OpenSkill objects. Warning Do not modify this unless you know what you're doing. Parameter Name Type Description Default Value newStartingMean number The new starting mean MatchmakingService : SetStartingMean ( newStartingMean ) Setting the Starting Ranking Standard Deviation Sets the starting standard deviation of OpenSkill objects. Warning Do not modify this unless you know what you're doing. Parameter Name Type Description Default Value newStartingStandardDeviation number The new starting standing deviation MatchmakingService : SetStartingStandardDeviation ( newStartingStandardDeviation ) Setting the Max Skill Gap Between Party Members Sets the max gap in rating between party members. Parameter Name Type Description Default Value newMaxGap number The new max gap between party members MatchmakingService : SetMaxPartySkillGap ( newMaxGap ) Setting the Seconds Between Queue Expansions Sets the number of seconds between each queue expansion. Parameter Name Type Description Default Value newValue number The new value, in seconds, of seconds between each queue expansion MatchmakingService : SetSecondsBetweenExpansion ( newValue ) Explaination An expansion is 10 rounded skill level in each direction. If a player is skill level 25, they get rounded to 30. A signle expansion from the 30 skill level queue will search also in 20 and 40. Setting the Seconds to Delay Teleporting Sets the number of seconds to delay teleporting after finding a game. If you want to so a UI, or something along those lines. Parameter Name Type Description Default Value newValue number The new value, in seconds, of the delay MatchmakingService : SetFoundGameDelay ( newValue ) Getting the Current Game's Code Gets the current game's code. This only works on game servers! MatchmakingService : GetCurrentGameCode () Returns Type Description string The game code of the current game Getting Game Data Gets a running game's data. This includes its code, ratingType, and any general game data you applied through the ApplyGeneralTeleportData function. This will not return custom player data, for that use GetUserData(player). Parameter Name Type Description Default Value code string The game's code MatchmakingService:GetCurrentGameCode() MatchmakingService : GetGameData ( code ) Returns Type Description table The game's data, if there is any gameData This game data should not be confused with the game data returned by GetRunningGame . This data has the following format, and includes custom data: { [ \"gameCode\" ] = string [ \"ratingType\" ] = string -- This table includes the data set by `ApplyGeneralTeleportData`. -- If you `return {[\"key\"]=\"value\"}` in `ApplyGeneralTeleportData`, -- then this table will include `[\"key\"] = \"value\"` as well. } Getting User Data Gets a user's custom data for the game they are currently in. This will return nil if they're not in a game, or if you haven't applied any custom data. Parameter Name Type Description Default Value player Player The player to get the data of MatchmakingService : GetUserData ( player ) Returns Type Description Variant The data set by ApplyCustomTeleportData for this player Obtaining a Rating Value from an OpenSkill Object Turns an OpenSkill object into a single rating number. Parameter Name Type Description Default Value openSkillObject OpenSkill object The OpenSkill object MatchmakingService : ToRatingNumber ( openSkillObject ) Returns Type Description number The single number representation of the object Obtaining an OpenSkill Object Gets or initializes a players OpenSkill object. Note You should not edit this directly unless you know what you're doing. Parameter Name Type Description Default Value player Player The player to get the OpenSkill object of ratingType string The rating type to get MatchmakingService : GetPlayerRating ( player , ratingType ) Returns Type Description OpenSkill object The OpenSkill object (which is just 2 numbers) Setting an OpenSkill Object Sets a player's skill. Note You should not edit this directly unless you know what you're doing. Parameter Name Type Description Default Value player Player The player to set the OpenSkill object of ratingType string The rating type to get rating OpenSkill object The new OpenSkill object MatchmakingService : SetPlayerRating ( player , ratingType , rating ) Clearing a Player's Info Clears the player info. Parameter Name Type Description Default Value player Player The player to clear MatchmakingService : ClearPlayerInfo ( player ) Setting a Player's info Sets the player info. Parameter Name Type Description Default Value player Player The player to update code string The game id that the player will teleport to, if any ratingType string The rating type of their current game, if any party table The player's party (table of user ids including the player) map string The player's queued map, if any teleportAfter number The time after which the player will be teleported MatchmakingService : SetPlayerInfo ( player , code , ratingType , party , map , teleportAfter ) Getting a Player's Info Gets the player info. Parameter Name Type Description Default Value player Player The player to get MatchmakingService : GetPlayerInfo ( player ) Returns Type Description table or nil The player info Getting all running games Gets all running games from memory. MatchmakingService : GetAllRunningGames () Returns Type Description table An array of {key: gameCode, value: gameData} dictionaries gameData Game data is the information tied to a game. Game data has this format: { [ \"full\" ] = boolean [ \"skillLevel\" ] = number [ \"players\" ] = table < \u200b PlayerId > [ \"started\" ] = boolean [ \"joinable\" ] = boolean [ \"ratingType\" ] = string [ \"map\" ] = string [ \"createTime\" ] = number } Getting running games Gets running games up to a specificed amount that pass a filter function. Parameter Name Type Description Default Value max number The maximum number of games to get filter function A filter function which is passed the game data. Should return true if passed MatchmakingService : GetRunningGames ( max , filter ) Returns Type Description table An array of {key: gameCode, value: gameData} dictionaries Getting a single running game Gets a single running game from memory. Parameter Name Type Description Default Value code string The unique code of the game nil MatchmakingService : GetRunningGame ( code ) Returns Type Description table A single game data dictionary or nil Getting the Queue Gets a table of user ids, ratingTypes, and skillLevels in a specific queue. Parameter Name Type Description Default Value map string The map to get the queue of MatchmakingService : GetQueue ( map ) Getting Queue Counts Counts the number of players in each queue and returns a table and number of all of them added together. MatchmakingService : GetQueueCounts () Returns Type Description table A dictionary of {map: {ratingType: count}} where map is the name of the map they queued for, ratingType is the ratingType they queue for, and count is the number of users in that queue number The total of all queue counts added together Queueing a Single Player Queues a player. Parameter Name Type Description Default Value player Player The player to queue ratingType string The rating type to use map string The map to queue them on MatchmakingService : QueuePlayer ( player , ratingType , map ) Returns Type Description boolean A boolean that is true if the player was queued Queueing a Party Queues a party. Parameter Name Type Description Default Value players table<\u200bPlayer> The players to queue ratingType string The rating type to use map string The map to queue them on MatchmakingService : QueueParty ( players , ratingType , map ) Returns Type Description boolean A boolean that is true if the party was queued Player The player that caused the queue to not start string The reason the queue did not start Note The second and third return values are nil if the first value is true. Getting a Player's Party Gets a player's party. Parameter Name Type Description Default Value player Player The player to get the party of MatchmakingService : GetPlayerParty ( player ) Returns Type Description table<\u200bnumber> A table of player id's of players in the party including this player Remove a Single Player from the Queue Removes a specific player from the queue. Parameter Name Type Description Default Value player Player The player to remove from queue MatchmakingService : RemovePlayerFromQueue ( player ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error) Remove Multiple Players from the Queue Removes a table of players from the queue. Parameter Name Type Description Default Value players table<\u200bPlayer> The players to remove from queue MatchmakingService : RemovePlayersFromQueue ( players ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error) Adding A Player to an Existing Game Adds a player to a specific existing game. Parameter Name Type Description Default Value player Player The player to add to the game gameId string The id of the game to add the player to updateJoinable boolean Whether or not to update the joinable status of the game MatchmakingService : AddPlayerToGame ( player , gameId , updateJoinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error) Adding Multiple Players to an Existing Game Adds a table of players to a specific existing game. Parameter Name Type Description Default Value player table<\u200bPlayer> The players to add to the game gameId string The id of the game to add the player to updateJoinable boolean Whether or not to update the joinable status of the game MatchmakingService : AddPlayersToGame ( players , gameId , updateJoinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error) Removing a Player from a Game Removes a specific player from an existing game. Parameter Name Type Description Default Value player Player The player to remove from the game gameId string The id of the game to remove the player from updateJoinable boolean Whether or not to update the joinable status of the game MatchmakingService : RemovePlayersFromGame ( players , gameId , updateJoinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error) Updating Ratings Update player ratings after a game is over. Parameter Name Type Description Default Value ratingType string The rating type this is applicable for ranks table<\u200bnumber> The ranks of the teams. #scores should be the same as the #teams teams table<\u200bPlayer> The teams. A table of tables which contain players MatchmakingService : UpdateRatings ( ratingType , ranks , teams ) Explaination Basically, lets have this scenario in the ratingType ranked: local team1 = { player1 , player2 } local team2 = { player3 , player4 } local team3 = { player5 , player6 } Let\u2019s say team2 came first, team1 came second and team3 came third. To update the ratings correctly, you would do this: MatchmakingService:UpdateRatings(\"ranked\", {2, 1, 3}, {team1, team2, team3}) {2,1,3} is important, and so is order. Order is extremely important here. Because I passed the teams in order, I can give the position of each team in order. As previously stated team1 placed second, therefore because team1 is the first team in the teams table, it also has the first value in the rankings table. Returns Type Description boolean A boolean indicating if there was no error (true if there was no error) Set the Game's Joinable Status Sets the joinable status of a game. Parameter Name Type Description Default Value gameId string The id of the game to update joinable boolean Whether or not the game will be joinable MatchmakingService : SetJoinable ( gameId , joinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error) Remove the Current Game from Memory Removes the current game from memory. This is called by MMS automatically since v2. You should only call this to remove a game, but keep the server running. MatchmakingService : RemoveGame () Returns Type Description boolean A boolean indicating if there was no error (true if there was no error) Start a Game Starts a game. Parameter Name Type Description Default Value gameId string The game to start joinable boolean Whether or not the game is still joinable MatchmakingService : StartGame ( gameId , joinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Main Documentation"},{"location":"maindocs/#preface","text":"This documentation will provide the insight on to every method available from Matchmaking Service. This will include methods intended for internal use, these are still documented, just in case you ever need them.","title":"Preface"},{"location":"maindocs/#note","text":"Every method here that involves a player object most likely also has an \"Id\" variant. Internally, everything is done with user ids, but the helper methods exist to streamline the process. This means if you see a method called RemovePlayersFromGame , there is another method called RemovePlayersFromGameId where instead of player objects, user ids are passed. If you're in doubt whether or not an id variant exists for the method you are using, I recommend looking through the source , if it exists, it will have the same name suffixed with Id . \"Id\" variants will not be listed here unless there is no regular variant.","title":"Note"},{"location":"maindocs/#obtaining-singleton","text":"Gets or creates the top level singleton of the matchmaking service. Parameter Name Type Description Default Value options table The options to provide matchmaking service {} options.MajorVersion string The major version to use nil options.DisableRatingSystem boolean Whether or not to disable the rating system false options.DisableExpansions boolean Whether or not to disable expansions false options.DisableGlobalEvents boolean Whether or not to disable global events false MatchmakingService . GetSingleton ( options ) Returns Type Description MatchmakingService The matchmaking service singleton","title":"Obtaining Singleton"},{"location":"maindocs/#clearing-the-memory","text":"Clears all memory aside from player data. MatchmakingService : Clear ()","title":"Clearing the Memory"},{"location":"maindocs/#listening-for-players-being-added-to-queue","text":"You can listen to players being added to the queue globally. This will fire in waves when coming from other servers. This is a signal, so you need to connect to it. Below is a table of what it passes, in order. Type Description number The player's UserId string The map the player queued for string The rating type the player queued for number The rounded rating value of the player. CAN BE NIL Connecting to the listener is simple: MatchmakingService . PlayerAddedToQueue : Connect ( function ( player , map , ratingType , roundedRating ) print ( player , map , ratingType , roundedRating ) end )","title":"Listening for Players Being Added to Queue"},{"location":"maindocs/#listening-for-players-being-removed-from-the-queue","text":"You can listen to players being removed from the queue globally. This will fire in waves when coming from other servers. This is a signal, so you need to connect to it. Below is a table of what it passes, in order. Type Description number The player's UserId string The map the player queued for string The rating type the player queued for number The rounded rating value of the player. CAN BE NIL Connecting to the listener is simple: MatchmakingService . PlayerRemovedFromQueue : Connect ( function ( player , map , ratingType , roundedRating ) print ( player , map , ratingType , roundedRating ) end )","title":"Listening for Players Being Removed from the Queue"},{"location":"maindocs/#listening-for-finding-games","text":"You can listen for when players find games. This signal is not global. Below is a table of what it passes, in order. Type Description number The player's UserId string The unique code which identifies the game table The game data MatchmakingService . FoundGame : Connect ( function ( player , gameCode , gameData ) print ( player , gameCode , gameData ) end )","title":"Listening for Finding Games"},{"location":"maindocs/#applying-custom-teleport-data-to-players","text":"You can apply custom teleport data to players to access it in the game when they are teleported. This is a function that you can bind to. You may only bind to it once. Below is a table of what it passes, in order. This function can return anything, but some things won't be replicated to other servers. Metatables and instances will not be passed correctly. This should mainly return strings and numbers, or a table of them so that you can reconstruct instances on the server, or just obtain general data that you need in the game. Type Description Player The Player table The game data You can bind this function like so: MatchmakingService . ApplyCustomTeleportData = function ( player , gameData ) return {[ \"Some\" ] = \"Custom\" ,[ \"Data\" ] = \"Table\" } end To retrieve it on the instance server where players are teleported to, you'll need to do something like this: game . Players . PlayerAdded : Connect ( function ( player ) local playerData = MatchmakingService : GetUserData ( player ) print ( playerData ) end ) The user id is passed as a string (this is out of our control, it is converted to a string when passed), so you must use tostring on player.UserId to properly get their data.","title":"Applying Custom Teleport Data to Players"},{"location":"maindocs/#applying-custom-teleport-data-to-the-game","text":"You can apply custom teleport data to the game overall (which may be conditional). This is a function that you can bind to. You may only bind to it once. Below is a table of what it passes, in order. This function can return anything, but some things won't be replicated to other servers. Metatables and instances will not be passed correctly. This should mainly return strings and numbers, or a table of them so that you can reconstruct instances on the server, or just obtain general data that you need in the game. Type Description table The game data You can bind this function like so: MatchmakingService . ApplyGeneralTeleportData = function ( gameData ) return {[ \"Some\" ] = \"Custom\" ,[ \"Data\" ] = \"Table\" } end To retrieve it on the instance server where players are teleported to, you'll need to do something like this: game . Players . PlayerAdded : Connect ( function ( player ) local gameData = MatchmakingService : GetGameData () -- gets the current game's data, includes custom data print ( gameData ) end ) The user id is passed as a string (this is out of our control, it is converted to a string when passed), so you must use tostring on player.UserId to properly get their data.","title":"Applying Custom Teleport Data to the Game"},{"location":"maindocs/#setting-matchmaking-interval","text":"Sets the matchmaking interval. Parameter Name Type Description Default Value newInterval number The new matchmaking interval MatchmakingService : SetMatchmakingInterval ( newInterval )","title":"Setting Matchmaking Interval"},{"location":"maindocs/#setting-the-player-range","text":"Sets the min/max players. Parameter Name Type Description Default Value map string The map the player range applies to newPlayerRange number The NumberRange with the min and max players MatchmakingService : SetPlayerRange ( map , newPlayerRange )","title":"Setting the Player Range"},{"location":"maindocs/#adding-a-new-map","text":"Add a new game place. Parameter Name Type Description Default Value name string The name of the map id number The place id to teleport to MatchmakingService : AddGamePlace ( name , id )","title":"Adding A New Map"},{"location":"maindocs/#seting-is-game-server","text":"Sets whether or not this is a game server. Note Disables match finding coroutine if newValue is true. Parameter Name Type Description Default Value newValue boolean A boolean that indicates whether or not this server is a game server updateJoinableOnLeave boolean A boolean that indicates whether or not to update the joinable status when a player leaves MatchmakingService : SetIsGameServer ( newValue , updateJoinableOnLeave )","title":"Seting Is Game Server"},{"location":"maindocs/#setting-the-starting-ranking-mean","text":"Sets the starting mean of OpenSkill objects. Warning Do not modify this unless you know what you're doing. Parameter Name Type Description Default Value newStartingMean number The new starting mean MatchmakingService : SetStartingMean ( newStartingMean )","title":"Setting the Starting Ranking Mean"},{"location":"maindocs/#setting-the-starting-ranking-standard-deviation","text":"Sets the starting standard deviation of OpenSkill objects. Warning Do not modify this unless you know what you're doing. Parameter Name Type Description Default Value newStartingStandardDeviation number The new starting standing deviation MatchmakingService : SetStartingStandardDeviation ( newStartingStandardDeviation )","title":"Setting the Starting Ranking Standard Deviation"},{"location":"maindocs/#setting-the-max-skill-gap-between-party-members","text":"Sets the max gap in rating between party members. Parameter Name Type Description Default Value newMaxGap number The new max gap between party members MatchmakingService : SetMaxPartySkillGap ( newMaxGap )","title":"Setting the Max Skill Gap Between Party Members"},{"location":"maindocs/#setting-the-seconds-between-queue-expansions","text":"Sets the number of seconds between each queue expansion. Parameter Name Type Description Default Value newValue number The new value, in seconds, of seconds between each queue expansion MatchmakingService : SetSecondsBetweenExpansion ( newValue ) Explaination An expansion is 10 rounded skill level in each direction. If a player is skill level 25, they get rounded to 30. A signle expansion from the 30 skill level queue will search also in 20 and 40.","title":"Setting the Seconds Between Queue Expansions"},{"location":"maindocs/#setting-the-seconds-to-delay-teleporting","text":"Sets the number of seconds to delay teleporting after finding a game. If you want to so a UI, or something along those lines. Parameter Name Type Description Default Value newValue number The new value, in seconds, of the delay MatchmakingService : SetFoundGameDelay ( newValue )","title":"Setting the Seconds to Delay Teleporting"},{"location":"maindocs/#getting-the-current-games-code","text":"Gets the current game's code. This only works on game servers! MatchmakingService : GetCurrentGameCode () Returns Type Description string The game code of the current game","title":"Getting the Current Game's Code"},{"location":"maindocs/#getting-game-data","text":"Gets a running game's data. This includes its code, ratingType, and any general game data you applied through the ApplyGeneralTeleportData function. This will not return custom player data, for that use GetUserData(player). Parameter Name Type Description Default Value code string The game's code MatchmakingService:GetCurrentGameCode() MatchmakingService : GetGameData ( code ) Returns Type Description table The game's data, if there is any gameData This game data should not be confused with the game data returned by GetRunningGame . This data has the following format, and includes custom data: { [ \"gameCode\" ] = string [ \"ratingType\" ] = string -- This table includes the data set by `ApplyGeneralTeleportData`. -- If you `return {[\"key\"]=\"value\"}` in `ApplyGeneralTeleportData`, -- then this table will include `[\"key\"] = \"value\"` as well. }","title":"Getting Game Data"},{"location":"maindocs/#getting-user-data","text":"Gets a user's custom data for the game they are currently in. This will return nil if they're not in a game, or if you haven't applied any custom data. Parameter Name Type Description Default Value player Player The player to get the data of MatchmakingService : GetUserData ( player ) Returns Type Description Variant The data set by ApplyCustomTeleportData for this player","title":"Getting User Data"},{"location":"maindocs/#obtaining-a-rating-value-from-an-openskill-object","text":"Turns an OpenSkill object into a single rating number. Parameter Name Type Description Default Value openSkillObject OpenSkill object The OpenSkill object MatchmakingService : ToRatingNumber ( openSkillObject ) Returns Type Description number The single number representation of the object","title":"Obtaining a Rating Value from an OpenSkill Object"},{"location":"maindocs/#obtaining-an-openskill-object","text":"Gets or initializes a players OpenSkill object. Note You should not edit this directly unless you know what you're doing. Parameter Name Type Description Default Value player Player The player to get the OpenSkill object of ratingType string The rating type to get MatchmakingService : GetPlayerRating ( player , ratingType ) Returns Type Description OpenSkill object The OpenSkill object (which is just 2 numbers)","title":"Obtaining an OpenSkill Object"},{"location":"maindocs/#setting-an-openskill-object","text":"Sets a player's skill. Note You should not edit this directly unless you know what you're doing. Parameter Name Type Description Default Value player Player The player to set the OpenSkill object of ratingType string The rating type to get rating OpenSkill object The new OpenSkill object MatchmakingService : SetPlayerRating ( player , ratingType , rating )","title":"Setting an OpenSkill Object"},{"location":"maindocs/#clearing-a-players-info","text":"Clears the player info. Parameter Name Type Description Default Value player Player The player to clear MatchmakingService : ClearPlayerInfo ( player )","title":"Clearing a Player's Info"},{"location":"maindocs/#setting-a-players-info","text":"Sets the player info. Parameter Name Type Description Default Value player Player The player to update code string The game id that the player will teleport to, if any ratingType string The rating type of their current game, if any party table The player's party (table of user ids including the player) map string The player's queued map, if any teleportAfter number The time after which the player will be teleported MatchmakingService : SetPlayerInfo ( player , code , ratingType , party , map , teleportAfter )","title":"Setting a Player's info"},{"location":"maindocs/#getting-a-players-info","text":"Gets the player info. Parameter Name Type Description Default Value player Player The player to get MatchmakingService : GetPlayerInfo ( player ) Returns Type Description table or nil The player info","title":"Getting a Player's Info"},{"location":"maindocs/#getting-all-running-games","text":"Gets all running games from memory. MatchmakingService : GetAllRunningGames () Returns Type Description table An array of {key: gameCode, value: gameData} dictionaries gameData Game data is the information tied to a game. Game data has this format: { [ \"full\" ] = boolean [ \"skillLevel\" ] = number [ \"players\" ] = table < \u200b PlayerId > [ \"started\" ] = boolean [ \"joinable\" ] = boolean [ \"ratingType\" ] = string [ \"map\" ] = string [ \"createTime\" ] = number }","title":"Getting all running games"},{"location":"maindocs/#getting-running-games","text":"Gets running games up to a specificed amount that pass a filter function. Parameter Name Type Description Default Value max number The maximum number of games to get filter function A filter function which is passed the game data. Should return true if passed MatchmakingService : GetRunningGames ( max , filter ) Returns Type Description table An array of {key: gameCode, value: gameData} dictionaries","title":"Getting running games"},{"location":"maindocs/#getting-a-single-running-game","text":"Gets a single running game from memory. Parameter Name Type Description Default Value code string The unique code of the game nil MatchmakingService : GetRunningGame ( code ) Returns Type Description table A single game data dictionary or nil","title":"Getting a single running game"},{"location":"maindocs/#getting-the-queue","text":"Gets a table of user ids, ratingTypes, and skillLevels in a specific queue. Parameter Name Type Description Default Value map string The map to get the queue of MatchmakingService : GetQueue ( map )","title":"Getting the Queue"},{"location":"maindocs/#getting-queue-counts","text":"Counts the number of players in each queue and returns a table and number of all of them added together. MatchmakingService : GetQueueCounts () Returns Type Description table A dictionary of {map: {ratingType: count}} where map is the name of the map they queued for, ratingType is the ratingType they queue for, and count is the number of users in that queue number The total of all queue counts added together","title":"Getting Queue Counts"},{"location":"maindocs/#queueing-a-single-player","text":"Queues a player. Parameter Name Type Description Default Value player Player The player to queue ratingType string The rating type to use map string The map to queue them on MatchmakingService : QueuePlayer ( player , ratingType , map ) Returns Type Description boolean A boolean that is true if the player was queued","title":"Queueing a Single Player"},{"location":"maindocs/#queueing-a-party","text":"Queues a party. Parameter Name Type Description Default Value players table<\u200bPlayer> The players to queue ratingType string The rating type to use map string The map to queue them on MatchmakingService : QueueParty ( players , ratingType , map ) Returns Type Description boolean A boolean that is true if the party was queued Player The player that caused the queue to not start string The reason the queue did not start Note The second and third return values are nil if the first value is true.","title":"Queueing a Party"},{"location":"maindocs/#getting-a-players-party","text":"Gets a player's party. Parameter Name Type Description Default Value player Player The player to get the party of MatchmakingService : GetPlayerParty ( player ) Returns Type Description table<\u200bnumber> A table of player id's of players in the party including this player","title":"Getting a Player's Party"},{"location":"maindocs/#remove-a-single-player-from-the-queue","text":"Removes a specific player from the queue. Parameter Name Type Description Default Value player Player The player to remove from queue MatchmakingService : RemovePlayerFromQueue ( player ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Remove a Single Player from the Queue"},{"location":"maindocs/#remove-multiple-players-from-the-queue","text":"Removes a table of players from the queue. Parameter Name Type Description Default Value players table<\u200bPlayer> The players to remove from queue MatchmakingService : RemovePlayersFromQueue ( players ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Remove Multiple Players from the Queue"},{"location":"maindocs/#adding-a-player-to-an-existing-game","text":"Adds a player to a specific existing game. Parameter Name Type Description Default Value player Player The player to add to the game gameId string The id of the game to add the player to updateJoinable boolean Whether or not to update the joinable status of the game MatchmakingService : AddPlayerToGame ( player , gameId , updateJoinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Adding A Player to an Existing Game"},{"location":"maindocs/#adding-multiple-players-to-an-existing-game","text":"Adds a table of players to a specific existing game. Parameter Name Type Description Default Value player table<\u200bPlayer> The players to add to the game gameId string The id of the game to add the player to updateJoinable boolean Whether or not to update the joinable status of the game MatchmakingService : AddPlayersToGame ( players , gameId , updateJoinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Adding Multiple Players to an Existing Game"},{"location":"maindocs/#removing-a-player-from-a-game","text":"Removes a specific player from an existing game. Parameter Name Type Description Default Value player Player The player to remove from the game gameId string The id of the game to remove the player from updateJoinable boolean Whether or not to update the joinable status of the game MatchmakingService : RemovePlayersFromGame ( players , gameId , updateJoinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Removing a Player from a Game"},{"location":"maindocs/#updating-ratings","text":"Update player ratings after a game is over. Parameter Name Type Description Default Value ratingType string The rating type this is applicable for ranks table<\u200bnumber> The ranks of the teams. #scores should be the same as the #teams teams table<\u200bPlayer> The teams. A table of tables which contain players MatchmakingService : UpdateRatings ( ratingType , ranks , teams ) Explaination Basically, lets have this scenario in the ratingType ranked: local team1 = { player1 , player2 } local team2 = { player3 , player4 } local team3 = { player5 , player6 } Let\u2019s say team2 came first, team1 came second and team3 came third. To update the ratings correctly, you would do this: MatchmakingService:UpdateRatings(\"ranked\", {2, 1, 3}, {team1, team2, team3}) {2,1,3} is important, and so is order. Order is extremely important here. Because I passed the teams in order, I can give the position of each team in order. As previously stated team1 placed second, therefore because team1 is the first team in the teams table, it also has the first value in the rankings table. Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Updating Ratings"},{"location":"maindocs/#set-the-games-joinable-status","text":"Sets the joinable status of a game. Parameter Name Type Description Default Value gameId string The id of the game to update joinable boolean Whether or not the game will be joinable MatchmakingService : SetJoinable ( gameId , joinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Set the Game's Joinable Status"},{"location":"maindocs/#remove-the-current-game-from-memory","text":"Removes the current game from memory. This is called by MMS automatically since v2. You should only call this to remove a game, but keep the server running. MatchmakingService : RemoveGame () Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Remove the Current Game from Memory"},{"location":"maindocs/#start-a-game","text":"Starts a game. Parameter Name Type Description Default Value gameId string The game to start joinable boolean Whether or not the game is still joinable MatchmakingService : StartGame ( gameId , joinable ) Returns Type Description boolean A boolean indicating if there was no error (true if there was no error)","title":"Start a Game"}]}